# Coding Guideline

> **Communicate in Japanese**
> (All responses generated by the AI must be in Japanese.)

- You are a highly skilled software engineer with extensive knowledge in many programming languages, frameworks, design patterns, and best practices.
- As a professional, you shall adhere to and code in accordance with the following practices

## 1. Commit Strategy

- **Commit with fine granularity**

  - Keep each commit as small as possible.
  - Ensure the change can be described in **≤ 30 Japanese characters**.
  - Include only the minimal code necessary for that change.

- **Follow DDD (Domain-Driven Design) principles** for every commit (see section 3).

## 2. Audible Notifications

| Context                                                   | Command                            |
| --------------------------------------------------------- | ---------------------------------- |
| When user input is required <br>_(SND.dev “piano” sound)_ | `afplay ~/.claude/caution.wav`     |
| On successful completion                                  | `afplay ~/.claude/celebration.wav` |

## 3. Core Principles

### 3.1 Functional approach (FP)

- Prefer pure functions
- Use invariant (immutable) data structures
- Represent success and failure explicitly with `Result<T, E>`
- Isolate side effects
- Ensure type safety

### 3.2 Domain Driven Design (DDD)

- Distinguish between **Value Objects** from **Entities**.
- Distinguish between **Domain Services** from **Application Services**.
- Use **Aggregates** to guarantee consistency.
- Access data through **Repositories**.
- Respect **Bounded Contexts**.

### 3.3 Test Driven Development (TDD)

- Follow the **Red → Green → Refactor** loop.
- Treat tests as specifications
- Iterate in small increments
- Continuous refactoring

## 4. Definition

### 4.1 **Domain Service** vs **Application Service**

- Domain Service

  - The group of functions that implement domain knowledge
  - It is implemented as a pure function without side effects, handling only the processing of pure business logic without any involvement of external libraries.(Examples: calculating points based on user behavior data, or computing lottery winning probabilities.)
  - As the service belonging to the DDD domain layer, it must not hold any references to infrastructure layers or to the application layer
  - In most cases it is not directly invoked by the application but rather through an application service.
  - If exceptions need to be raised within the logic, the return value should adopt a Result type however, if there are no exception cases, the return value should not use a Result type

- Application Service
  - The group of classes that implement specific use cases by coordinating multiple domain objects and services
  - It implemented as classes often using dependency injection, depend on infrastructure layers such as repositories and transaction managers
  - It is directly invoked by the application (e.g., UI or API).
  - The processing is executed through an execute method, and if transactions are involved, it must always be encapsulated within a transaction class.
  - If exceptions need to be raised within the logic, the return value should adopt a Result type however, if there are no exception cases, the return value should not use a Result type

> **Communicate in Japanese**
> (All responses generated by the AI must be in Japanese.)

### 4.2 **Repository**

#### 4.2.1 Overview

- Abstracts access to persistence mechanisms for domain models.
- **Enforce dependency direction**: **Domain Layer ← Infrastructure Layer**
  - The **interface** of the repository resides in the domain layer,  
    while the concrete **implementation** is placed in the infrastructure layer,  
    ensuring the domain layer never depends on infrastructure.
- Expose only methods whose side‑effect boundaries are clear, e.g., _save / find / delete / exists_.
- **Application Services** are responsible for transaction control; the repository’s responsibility remains limited.
- Represent exceptions or failures with `Result<T, E>` and let the caller handle them.

#### 4.2.2 Aggregate Repositories

- **One repository per aggregate root** is the rule. Creation and updates of child entities are executed by the repository **within the same transaction**.
  - Details such as the creation order “parent → child” and obtaining the parent ID are **completely hidden from the Application Service**.
- When a parent ID is required, either **pre‑generate a ULID/UUID** or use the ORM’s **nested create** feature to persist while maintaining consistency.
- For use cases that span multiple aggregates, the Application Service **coordinates multiple repositories** and wraps them with a single transaction boundary.

### 4.3 **DTO (Data Transfer Object)**

- **層間通信専用** のイミュータブルデータ構造で、ビジネスロジックを一切持たない
- シリアライズ／デシリアライズを前提とし、**生成時に入力検証を完結** させる
- 命名規則は `<UseCase 名>Dto` を推奨

### 4.4 **Transaction Manager**

- トランザクションの **begin / commit / rollback** を DB ライブラリ依存を隠蔽して提供する **インフラ層コンポーネント**
- `ITransactionManager` インターフェースはアプリケーション層から参照可能とし、実装はインフラ層に配置
- **アプリケーションサービス** は「いつトランザクションを張るか」を判断して `runInTx` を呼ぶだけ
  - これによりユースケースの一貫性境界をコードで明確にできる
- **リポジトリ実装** は `ctx` に含まれる ORM クライアントを受け取り CRUD を実行し、開始済みトランザクションに参加する
- この分離により **ORM 交換** や **分散トランザクション対応** が必要になった場合も、アプリケーション層より上は無変更で差し替え可能

### 4.3 **DTO (Data Transfer Object)**

- Immutable data structures dedicated to **inter‑layer communication**; they must contain **no business logic**.
- Designed for serialization / deserialization; all **input validation must be completed when constructing the DTO**.
- Recommended naming convention: `<UseCaseName>Dto` (e.g., `RegisterUserRequestDto`).
- Centralise mapping logic in an **Assembler** or dedicated factory function to avoid duplication.

### 4.4 **Transaction Manager**

- An **infrastructure‑layer component** that hides DB‑library specifics while providing **begin / commit / rollback** semantics.
- Expose an `ITransactionManager` interface to the application layer; concrete implementations live in the infrastructure layer.
- **Application Services** decide _when_ to open a transaction and simply call `runInTx`, making the consistency boundary explicit in code.
- **Repository implementations** receive the ORM client inside `ctx` and perform CRUD within the already‑opened transaction.
- This separation allows **ORM replacement** or **distributed‑transaction support** without any changes above the application layer.
