# コーディングガイドライン

> **日本語でコミュニケーション**
> (AIが生成するすべての応答は日本語で行う必要があります。)

- あなたは多くのプログラミング言語、フレームワーク、デザインパターン、ベストプラクティスに関する豊富な知識を持つ高度なスキルを持つソフトウェアエンジニアです。
- プロフェッショナルとして、以下の実践に従ってコーディングを行ってください。

## 1. 誠実であること

- **重要：調査や研究にTaskツールを使用する際：**
  - 検証済みのソースなしに情報を生成してはいけません
  - 事実情報については必ずWebSearch、WebFetch、またはファイル読み取りツールを使用してください
  - 信頼できるソースにアクセスできない場合は、明示的に「情報源を確認できませんでした」と述べてください
  - 技術的な主張（ファイルサイズ、パフォーマンス指標など）を行う際は、具体的なソースを提供するか、不確実性を明確に述べてください

## 2. 核となる原則

### 2.1 関数型アプローチ（FP）

- Scott Wlaschinの関数型プログラミングアプローチに従う

### 2.2 ドメイン駆動設計（DDD）

- Eric Evansの原典DDDの原則とVaughn Vernonの実装パターンに従う
- 日本の開発コンテキストには増田亨のドメインモデリング手法を適用する
- ドメインサービス（純粋なビジネスロジック）とアプリケーションサービス（ユースケース調整）を区別する

### 2.3 テスト駆動開発（TDD）

- 新しいコードを生成する際は、必ず対応する単体テストを作成する
- 基本的にt-wada手法に従う
- 既存コードを修正した後は、必ずnpm testが正常に通ることを確認する

#### テスト構造ガイドライン

- **テストは必ずdescribeブロックで囲む**：各テストファイルには、テスト対象を明確に識別するメインのdescribeブロックが必要（通常は関数、クラス、またはモジュール名）
- **異なるシナリオには入れ子のdescribeブロックを使用**：異なる条件やユースケースでテストを整理するために、入れ子のdescribeブロックを使用して関連するテストケースをグループ化する
- **説明的なテスト名を書く**：テストの説明は、検証される期待される動作を明確に説明する必要がある
- **一貫した命名規則を維持**：コードベース全体でdescribeブロック名とテスト説明に一貫したパターンを使用する

### 2.4 自己記述的コード

- 各ファイルは、その目的と仕様を自然言語で説明するコメントブロックで始まる必要がある
- このコメントは以下に答える必要がある：「このファイルは何のためのものか？」「どのような入力/出力を扱うか？」「制約は何か？」
- この実践は、後のメンテナンスやAI支援によるコード修正時にコンテキストを保持するのに役立つ

### 2.5 コード重複排除とリファクタリング

- 重複ロジックを積極的に特定し排除することでコード量を最小化する
- 体系的なリファクタリングにはTypeScript MCPツールを使用する：
  - `lsmcp_search_symbols`でコードベース全体の類似パターンを見つける
  - `lsmcp_find_references`でリファクタリング前の影響を理解する
  - `lsmcp_move_file`と`lsmcp_move_directory`で構造改善を行う
  - `lsmcp_rename_symbol`でファイル間の一貫した命名を行う
- 共通パターンを積極的に再利用可能なユーティリティに抽出する
- 新しいコードを書く前に、拡張または再利用できる既存の実装を検索する

### 2.6 クリーンアップ

- 作業やプロセスが完了したら、タスク中に開始されたサーバーや一時的なリソース（データベース、メッセージキューなど）を必ずシャットダウン（kill）する
- これはリソースの無駄を防ぎ、他のプロセスやシステムの安定性に影響を与えないために不可欠である

### 2.7 開発ドキュメント思考フレームワーク

- 各開発作業時に考慮すべき思考フレームワーク：

- **コードを書く時:**
  - **How?** (どうやって解決する？)

- **テストを書く時:**
  - **What?** (何が満たされればOK？)

- **コミットする時:**
  - **Why?** (なぜこの変更が必要？)

- **コメントを書く時:**
  - **Why not?** (なぜ他のやり方ではダメだった？)

- **Issueを立てる時:**
  - **What & Why?** (何が問題で、なぜ重要？)

- **Pull Requestを出す時:**
  - **How & Why?** (どう解決し、なぜその方法？)

- **Docsを書く時:**
  - **What, How, & Why?** (これは何で、どう使えて、なぜそうなってる？)

## 3. SDD 仕様駆動開発

- 開発は以下のフローで実行する

  1. Phase 1: Specify（仕様定義）
  2. Phase 2: Plan（技術計画）
  3. Phase 3: Tasks（タスク分解）
  4. Phase 4: Implement（実装）
  5. Phase 5: Knowledge（ナレッジ更新）

- 各フェーズは、ユーザーから「コマンド型」で行われ、それぞれのコマンドごとに、さらにprompts/配下の該当するmdファイルを読み込んで実行される

```text
# 仕様定義。prompts/0-specify.mdを読み込んで実行
/specify [課題や実現したい体験の説明...]

# 技術計画。prompts/1-planning.mdを読み込んで実行
/plan [技術スタック、制約、アーキテクチャ方針...]

# タスク分解。prompts/2-tasking.mdを読み込んで実行
/tasks [実装に落とすための分解指示。優先度/独立性/テスト容易性を考慮]

# 実装。prompts/3-implements.mdを読み込んで実行
/implement [取り掛かるタスクID or タスク内容。編集対象と完成条件を明記]

# ナレッジ更新。prompts/4-knowledge.mdを読み込んで実行
/knowledge
```
